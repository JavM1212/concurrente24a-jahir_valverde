struct goldbach_number 
  int64_t number
  int64_t amount_of_sums
  int64_t* sums /// arreglo en memoria
end struct

struct prime_numbers
  int64_t amount
  int64_t* numbers /// arreglo en memoria
end struct

procedure main
  allocate array in memory input_list := receive_input()

  allocate array in memory goldbach_numbers with the sizeof len(input_list)

  for i := 0 to len(input_list) do
    goldbach_numbers[i] = calc_goldbach_number(input_list[i])
  end for

  print_goldbach_numers(goldbach_numbers)
end procedure

procedure calc_goldbach_number(integer number)
  allocate cell in memory goldbach_number
  goldbach_number->number = number

  /// Determinar si es mayor que 5 (sino lo es, devuelve NA)
  if not (number > 5 or number < -5) do
    goldbach_number->amount_of_sums = 0
    goldbach_number->sums = 0
    return goldbach_number
  end if

  if number < 0 do
    is_negative = -1
  else
    is negative = 1
  end if

  /// Calcular los numeros primos menores numero con criba de eratostenes
  allocate array in memory prime_numbers := calc_prime_numbers(number)

  initialize array in memory goldbach_number->sums
  if number is odd do
    for i := 0 to len(prime_numbers) do
      for j := i to len(prime_numbers) do
          for k := j to len(prime_numbers) do
            if (prime_numbers[i] + prime_numbers[j] + prime_numbers[k]) = number * is_negative do
              if is_negative = -1 do
                reallocate goldbach_number->sums adding 3 blocks of the sizeof(struct goldbach_number)
                goldbach_number[(goldbach_number->amount_of_sums * 3) + 0] =: prime_numbers[i]
                goldbach_number[(goldbach_number->amount_of_sums * 3) + 1] =: prime_numbers[j]
                goldbach_number[(goldbach_number->amount_of_sums * 3) + 2] =: prime_numbers[k]
              else 
                goldbach_number->sums = 0
              end if
              add 1 to goldbach_number->amount_of_sums
            end if
          end for
      end for  
    end for
  end if

  if number is even do
    for i := 0 to len(prime_numbers) do
      for j := i to len(prime_numbers) do
          if (prime_numbers[i] + prime_numbers[j]) = number * is_negative do
            if is_negative = -1 do
              reallocate goldbach_number->sums adding 2 blocks of the sizeof(struct goldbach_number)
              goldbach_number[(goldbach_number->amount_of_sums * 2) + 0] =: prime_numbers[i]
              goldbach_number[(goldbach_number->amount_of_sums * 2) + 1] =: prime_numbers[j]
            else 
              goldbach_number->sums = 0
            end if
            add 1 to goldbach_number->amount_of_sums
          end if
      end for  
    end for
  end if

  return goldbach_number
end procedure

/// Plan para calcular sumas de goldbach:
/// 1. Recibir el numero
/// 2. Determinar si es mayor que 5 (sino lo es, devuelve NA)
/// 3. Calcular los numeros primos menores numero
/// 4. Determinar si es par o impar
///    1. Si es par, hacer for desde i = 0, j = i, e ir ingresando en una
///       arreglo las sumas
///    2. Si es impar, hacer for desde i = 0; j = i; k = j, e ir ingresando 
///       en un arreglo las sumas
