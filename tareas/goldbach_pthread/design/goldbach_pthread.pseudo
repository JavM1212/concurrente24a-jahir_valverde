struct input_t
  int64_t* input_arr
  int64_t size
  pthread_t* threads;
end struct

struct goldbach_number_t
  int64_t number
  int64_t amount_of_sums
  int64_t* sums
end struct

struct prime_numbers_t
int64_t* prime_numbers
int64_t size
end struct

struct my_work_t
  int64_t* my_input;
  goldbach_number_t** my_goldbach_numbers;
  int64_t assigned_work_units;
end struct

procedure main
  declare 1 space in memory of the size of input_t with name user_input := receive_input()
  declare 1 space in memory of the size of int64_t with name thread_count := analyze_arguments()
  declare user_input->size spaces in memory of the size of goldbach_number_t with name goldbach_numbers

  create_threads(user_input, goldbach_numbers, thread_count)

  join_threads(thread_count)

  print_goldbach_numers(goldbach_numbers)

  clear memory
end procedure

procedure create_threads(user_input, goldbach_numbers, thread_count)
  declare thread_count spaces in memory of the size of my_work_t with name my_works

  for thread := 0 to thread_count do
    declare 1 space in memory of the size of int with 
    name start := get_static_block_start(thread, user_input->size, thread_count)

    declare 1 space in memory of the size of int with 
    name finish := get_static_block_start(thread + 1, user_input->size, thread_count)

    /// se le suman los offset calculados a las estructuras de memoria
    my_works[thread].my_input = input->input_arr + start
    my_works[thread].my_goldbach_numbers = goldbach_numbers + start
    /// se calcula el size del subarreglo correspondiente
    my_works[thread].assigned_work_count = finish - start

    create_thread(run_thread, my_works[thread]);
  end for
end procedure

/// con la formula de mapeo por bloque que provee el profesor en la pagina, 
/// basta la estructura donde resultaran las sumas de goldbach y la estructura 
/// del input del usuario y la cantidad de trabajo asignada para trabajar
procedure run_thread(my_work)
  for i := 0 to assigned_work_count do
    my_work->goldbach_numbers[i] = calc_goldbach_number(my_work->my_input[i])
  end for
end procedure

procedure get_static_block_start(i, D, w)
  min = get_static_block_min(i, (D % w));
  return i * (D / w) + min;
end procedure

procedure get_static_block_min(i, mod)
  if (i < mod) {
    return i;
  }
  if (i > mod) {
    return mod;
  }
  // i == mod 
  return i;
end procedure

/// no incluyo receive_input() y calc_goldbach_number() porque es redundante
/// a la entrega 1
/// aqui me voy a enfocar en el flujo concurrente
